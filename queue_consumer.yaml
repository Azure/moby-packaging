parameters:
  - name: num_messages
    displayName: number of messages to process
    type: string
    default: "32" # max number of allowed messages
  - name: build_id
    displayName: build id
    type: string
    default: "__not_supplied"
  - name: storage_account_name
    displayName: Storage Account Name
    type: string
    default: moby
  - name: index_container
    displayName: Storage Container for storing index
    type: string
    default: index
  - name: rebuild
    displayName: Full index rebuild (destructive)
    type: boolean
    default: false

trigger: none

schedules:
 - cron: "0 2,10,18 * * *"
   displayName: "Process Queue"
   always: true
   branches:
     include:
       - main

name: ${{ replace(parameters.build_id, '__not_supplied', '$(Date:yyyyMMdd)') }}.$(Rev:r)

variables:
  build.pool: staging-pool-amd64-mariner-2

stages:
  - stage: ReadQueue
    jobs:
      - job: Pull_Messages
        pool: $(build.pool)
        steps:
          - bash: |
              set -exu

              az login --identity
              mkdir "$MSG_DIR"
              go run ./cmd/pop get-messages | tee "$MSG_DIR/message"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Pull Messages from Queue
            name: GetMessages
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
          - bash: |
              set -exu
              num_messages_found=$(jq 'length' < "$MSG_DIR/message")
              echo "##vso[task.setvariable variable=nummessages;isOutput=true]$num_messages_found"

              if [ $num_messages_found -ne 0 ]; then
                exit 0
              fi

              # otherwise, cancel the rest of this pipeline & log that there were no queue messages
              echo "##vso[build.updatebuildnumber]$UPDATED_BUILD_NUMBER"
              echo "##[warning]no new queue messages"

              # just in case, to avoid token leaking
              set +x

              # cancel the build
              curl -L -X PATCH \
                -H 'Authorization: Bearer $(System.AccessToken)' \
                -H 'Content-Type: application/json' \
                -d '{"status": "Cancelling"}' \
                'https://dev.azure.com/AzureContainerUpstream/Moby/_apis/build/builds/$(Build.BuildId)?api-version=7.0'
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
              UPDATED_BUILD_NUMBER: "${{ parameters.build_id }}.no.new.queue.messages"
            displayName: "Cancel Build if there are no Messages"
  - stage: SignAndPublish
    dependsOn: ["ReadQueue"]
    jobs:
      - job: Read_Queue
        pool: production-pool-amd64-mariner-2
        condition: ne(stageDependencies.ReadQueue.Pull_Messages.outputs['GetMessages.nummessages'], '0')
        steps:
          - download: current
            artifact: messages
          - bash: |
              set -eu
              # downloads all packages, puts them in out-dir, logs successful downloads to stdout (put in 'downloaded' file)
              go run ./cmd/pop download --out-dir="$OUT_DIR" --messages-file="$MSG_DIR/message" | tee "$MSG_DIR/downloaded"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
              OUT_DIR: "$(Pipeline.Workspace)/downloaded"
            displayName: Pull Queued Packages
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | @base64d | fromjson.artifact.name' < "$MSG_DIR/failed_downloading")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed downloading:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed downloads
          - bash: |
              cp -r $(Pipeline.Workspace)/downloaded $(Pipeline.Workspace)/signed
            displayName: Copy downloaded files to sign
          - task: UseDotNet@2
            displayName: Install .NET Core SDK
            inputs:
              packageType: sdk
              version: 2.2.207
          - template: templates/sign.steps.yml
            parameters:
              folderPath: "$(Pipeline.Workspace)/signed"
          - bash: |
              set -eu
              # uploads signed files to prod bucket, removes unsigned / failed uploads, writes output to stdout
              go run ./cmd/pop upload \
                --signed-dir="$SIGNED_DIR" \
                --messages-file="$MSG_DIR/downloaded" |
                tee "$MSG_DIR/succeeded"
            env:
              SIGNED_DIR: "$(Pipeline.Workspace)/signed"
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Upload Signed Packages to Prod Storage
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | @base64d | fromjson.artifact.name' < "$MSG_DIR/failed_singing_or_publishing")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed signing or uploading:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed uploads
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
          # Update latest index
          - bash: scripts/generate-versions.sh
            displayName: Generate versions
            env:
              AZURE_STORAGE_ACCOUNT: ${{ parameters.storage_account_name }}
              STORAGE_CONTAINER: mobyreleases
              OUTPUT: $(Build.ArtifactStagingDirectory)
          - task: PublishBuildArtifacts@1
            displayName: Store pipeline artifacts
            inputs:
              artifactName: versions
          - bash: |
              set -e

              az storage container create -n "${STORAGE_CONTAINER}" --auth-mode=login --public-access=blob

              if [ "${REBUILD_INDEX}" = "1" ]; then
                az storage blob delete-batch --source "${STORAGE_CONTAINER}" --auth-mode=login --pattern=*
              fi

              az storage blob upload-batch \
                --max-connections=10 --auth-mode=login \
                --overwrite \
                --source "${BUILD_ARTIFACTSTAGINGDIRECTORY}/" \
                --destination "${STORAGE_CONTAINER}" \
                --destination-path "/" \
                --pattern "*.json" \
                --content-type "application/json"

              az storage blob upload-batch \
                --max-connections=10 --auth-mode=login \
                --overwrite \
                --source "${BUILD_ARTIFACTSTAGINGDIRECTORY}/" \
                --destination "${STORAGE_CONTAINER}" \
                --destination-path "/" \
                --pattern "*.rss" \
                --content-type "application/rss+xml"

              az storage blob upload-batch \
                --max-connections=10 --auth-mode=login \
                --overwrite \
                --source "${BUILD_ARTIFACTSTAGINGDIRECTORY}/" \
                --destination "${STORAGE_CONTAINER}" \
                --destination-path "/" \
                --pattern "**/latest/*" \
                --content-type "text/plain"
            displayName: Upload versions to blob storage
            env:
              AZURE_STORAGE_ACCOUNT: ${{ parameters.storage_account_name }}
              STORAGE_CONTAINER: ${{ parameters.index_container }}
              ${{ if eq(parameters.rebuild, 'true') }}:
                REBUILD_INDEX: "1"
  - stage: FixupQueue
    dependsOn: ["ReadQueue", "SignAndPublish"]
    jobs:
      - job: FixupQueue
        pool: $(build.pool)
        condition: ne(stageDependencies.ReadQueue.Pull_Messages.outputs['GetMessages.nummessages'], '0')
        steps:
          - download: current
            artifact: messages
          - bash: |
              set -eu

              # removes successfully signed & published artifacts from the queue
              go run ./cmd/pop fixup-queue \
                --messages-file="$MSG_DIR/succeeded" |
                tee "$MSG_DIR/removed_from_queue"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Remove successful items from the queue
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | @base64d | fromjson.artifact.name' < "$MSG_DIR/failed_deleting_from_queue")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed removing from queue:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed message removals
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
