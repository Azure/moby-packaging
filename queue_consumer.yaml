parameters:
  - name: num_messages
    displayName: number of messages to process
    type: string
    default: "32" # max number of allowed messages
  - name: build_id
    displayName: build id
    type: string
    default: "__not_supplied"
  - name: prod_storage_account_name
    displayName: Storage Account Name
    type: string
    default: mobyreleases
  - name: index_container
    displayName: Storage Container for storing index
    type: string
    default: index

trigger: none

schedules:
 - cron: "0 18 * * *"
   displayName: "Process Queue"
   always: true
   branches:
     include:
       - main

name: ${{ replace(parameters.build_id, '__not_supplied', '$(Date:yyyyMMdd)') }}.$(Rev:r)

variables:
  build.pool: staging-pool-amd64-mariner-2

stages:
  - stage: PullMessages
    jobs:
      - job: Pull_Messages
        pool: $(build.pool)
        steps:
          - bash: |
              set -exuo pipefail

              az login --identity
              mkdir "$MSG_DIR"
              go run ./cmd/pop get-messages | tee "$MSG_DIR/message"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Pull Messages from Queue
            name: GetMessages
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
          - bash: |
              set -exuo pipefail
              num_messages_found=$(jq 'length' < "$MSG_DIR/message")
              echo "##vso[task.setvariable variable=nummessages;isOutput=true]$num_messages_found"

              if [ $num_messages_found -ne 0 ]; then
                exit 0
              fi

              # otherwise, cancel the rest of this pipeline & log that there were no queue messages
              time_of_run="$(date +%s)"
              echo "##vso[build.updatebuildnumber]$time_of_run.$NO_MSGS_MSG"
              echo "##[warning]no new queue messages"

              # just in case, to avoid token leaking
              set +x

              # cancel the build
              curl -L -X PATCH \
                -H 'Authorization: Bearer $(System.AccessToken)' \
                -H 'Content-Type: application/json' \
                -d '{"status": "Cancelling"}' \
                'https://dev.azure.com/AzureContainerUpstream/Moby/_apis/build/builds/$(Build.BuildId)?api-version=7.0'
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
              NO_MSGS_MSG: "no.new.queue.messages"
            displayName: "Cancel Build if there are no Messages"
  - stage: SignAndPublish
    dependsOn: ["PullMessages"]
    jobs:
      - job: Download_Artifacts
        pool: production-pool-amd64-mariner-2
        steps:
          - download: current
            artifact: messages
          - bash: |
              set -euo pipefail
              # downloads all packages, puts them in out-dir, logs successful downloads to stdout (put in 'downloaded' file)
              go run ./cmd/pop download --out-dir="$OUT_DIR" --messages-file="$MSG_DIR/message" | tee "$MSG_DIR/downloaded"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
              OUT_DIR: "$(Pipeline.Workspace)/downloaded"
            displayName: Pull Queued Packages
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | @base64d | fromjson.artifact.name' < "$MSG_DIR/failed_downloading")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed downloading:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed downloads
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/downloaded"
              artifactName: downloaded
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
      - job: Sign_Packages
        dependsOn: ["Download_Artifacts"]
        pool: production-pool-amd64-mariner-2
        steps:
          - download: current
            artifact: messages
          - download: current
            artifact: downloaded
          - bash: |
              cp -r $(Pipeline.Workspace)/downloaded $(Pipeline.Workspace)/signed
            displayName: Copy downloaded files to sign
          - bash: |
              set -exu

              win_dir="$SIGNED_DIR/windows"
              linux_dir="$SIGNED_DIR/linux"

              mkdir -p "$win_dir" "$linux_dir"
              find "$SIGNED_DIR" -maxdepth 1 -type f -name "*.zip" -exec mv {} "$win_dir" \;
              find "$SIGNED_DIR" -maxdepth 1 -type f -not -name "*.zip" -exec mv {} "$linux_dir" \;
            displayName: Separate windows and linux artifacts
            env:
              SIGNED_DIR: "$(Pipeline.Workspace)/signed"
          - task: UseDotNet@2
            displayName: Install .NET Core SDK
            inputs:
              packageType: sdk
              version: 2.2.207
          - template: templates/sign.steps.yml
            parameters:
              rootDir: "$(Pipeline.Workspace)/signed"
          - bash: |
              set -exu

              win_dir="$SIGNED_DIR/windows"
              linux_dir="$SIGNED_DIR/linux"

              rm -rf "$SIGNED_DIR/extracted"
              find "$SIGNED_DIR" -type f -exec mv {} "$SIGNED_DIR" \;
              rm -rf "$win_dir" "$linux_dir"
            displayName: Combine windows and linux artifacts
            env:
              SIGNED_DIR: "$(Pipeline.Workspace)/signed"
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/signed"
              artifactName: signed
      - job: Upload_Packages
        dependsOn: ["Download_Artifacts", "Sign_Packages"]
        pool: production-pool-amd64-mariner-2
        steps:
          - download: current
            artifact: messages
          - download: current
            artifact: signed
          - bash: |
              set -euo pipefail

              # uploads signed files to prod bucket, removes unsigned / failed uploads, writes output to stdout
              go run ./cmd/pop upload \
                --signed-dir="$SIGNED_DIR" \
                --messages-file="$MSG_DIR/downloaded" |
                tee "$MSG_DIR/succeeded"
            env:
              SIGNED_DIR: "$(Pipeline.Workspace)/signed"
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Upload Signed Packages to Prod Storage
            name: uploadPackages
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | @base64d | fromjson.artifact.name' < "$MSG_DIR/failed_singing_or_publishing")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed signing or uploading:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed uploads
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
      - job: Update_Latest
        dependsOn: ["Download_Artifacts", "Sign_Packages", "Upload_Packages"]
        pool: production-pool-amd64-mariner-2
        steps:
          - checkout: self
          - bash: az login --identity
            displayName: Login to Azure
          - bash: scripts/generate-versions.sh
            displayName: Generate versions
            env:
              AZURE_STORAGE_ACCOUNT: ${{ parameters.prod_storage_account_name }}
              STORAGE_CONTAINER: moby
              OUTPUT: $(Build.ArtifactStagingDirectory)
          - task: PublishBuildArtifacts@1
            displayName: Store pipeline artifacts
            inputs:
              artifactName: versions
          - bash: |
              set -ex

              az storage container create -n "${STORAGE_CONTAINER}" --auth-mode=login --public-access=blob

              az storage blob upload-batch \
                --max-connections=10 --auth-mode=login \
                --overwrite \
                --source "${BUILD_ARTIFACTSTAGINGDIRECTORY}/" \
                --destination "${STORAGE_CONTAINER}" \
                --destination-path "/" \
                --pattern "*.json" \
                --content-type "application/json"

              az storage blob upload-batch \
                --max-connections=10 --auth-mode=login \
                --overwrite \
                --source "${BUILD_ARTIFACTSTAGINGDIRECTORY}/" \
                --destination "${STORAGE_CONTAINER}" \
                --destination-path "/" \
                --pattern "*.rss" \
                --content-type "application/rss+xml"

              az storage blob upload-batch \
                --max-connections=10 --auth-mode=login \
                --overwrite \
                --source "${BUILD_ARTIFACTSTAGINGDIRECTORY}/" \
                --destination "${STORAGE_CONTAINER}" \
                --destination-path "/" \
                --pattern "**/latest/*" \
                --content-type "text/plain"
            displayName: Upload versions to blob storage
            env:
              AZURE_STORAGE_ACCOUNT: ${{ parameters.prod_storage_account_name }}
              STORAGE_CONTAINER: ${{ parameters.index_container }}
  - stage: FixupQueue
    dependsOn: ["PullMessages", "SignAndPublish"]
    condition: succeededOrFailed()
    jobs:
      - job: FixupQueue
        pool: $(build.pool)
        steps:
          - download: current
            artifact: messages
          - bash: |
              set -euo pipefail

              if ! [ -f "$MSG_DIR/succeeded" ]; then
                exit 0
              fi

              # removes successfully signed & published artifacts from the queue
              go run ./cmd/pop fixup-queue \
                --messages-file="$MSG_DIR/succeeded" |
                tee "$MSG_DIR/removed_from_queue"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Remove successful items from the queue
          - bash: |
              if ! [ -f "$MSG_DIR/failed_deleting_from_queue" ]; then
                exit 0
              fi

              readarray -t failed < <(jq -r '.[] | .content | @base64d | fromjson.artifact.name' < "$MSG_DIR/failed_deleting_from_queue")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed removing from queue:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed message removals
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
