parameters:
  - name: num_messages
    displayName: number of messages to process
    type: string
    default: "30"
  - name: build_id
    displayName: build id
    type: string
    default: "__not_supplied"

name: ${{ replace(parameters.build_id, '__not_supplied', '$(Date:yyyyMMdd)') }}.$(Rev:r)

variables:
  build.pool: staging-pool-amd64-mariner-2

stages:
  - stage: ReadQueue
    jobs:
      - job: Pull_Messages
        pool: $(build.pool)
        steps:
          - bash: |
              set -exu
              mkdir "$MSG_DIR"
              az login --identity
              az storage message get \
                --auth-mode login \
                --account-name moby \
                --queue-name moby-packaging-signing-and-publishing \
                --visibility-timeout 1 \
                --num-messages "$NUM_MESSAGES" |
                tee "$MSG_DIR/message"
            env:
              NUM_MESSAGES: "${{ parameters.num_messages }}"
              MSG_DIR: "$(Pipeline.Workspace)/messages"
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
  - stage: SignAndPublish
    jobs:
      - job: Read_Queue
        pool: production-pool-amd64-mariner-2
        steps:
          - download: current
            artifact: messages
          - bash: |
              set -exu
              # downloads all packages, puts them in out-dir, logs successful downloads to stdout (put in 'downloaded' file)
              go run ./cmd/pop download --out-dir="$OUT_DIR" --messages-file="$MSG_DIR/message" | tee "$MSG_DIR/downloaded"
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
              OUT_DIR: "$(Pipeline.Workspace)/downloaded"
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | fromjson.artifact.name' < "$MSG_DIR/failed_downloading")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed downloading:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed downloads
          - bash: |
              cp -r $(Pipeline.Workspace)/downloaded $(Pipeline.Workspace)/signed
            displayName: Copy downloaded files to sign
          - template: templates/sign.steps.windows.yml
            parameters:
              folderPath: $(Pipeline.Workspace)/signed
              pattern: '*.exe'
          - template: templates/sign.steps.linux.yml
            parameters:
              folderPath: $(Pipeline.Workspace)/signed
              pattern: '*'
          - bash: |
              # uploads signed files to prod bucket, removes unsigned / failed uploads, writes output to stdout
              go run ./cmd/pop upload \
                --signed-dir="$SIGNED_DIR" \
                --messages-file="$MSG_DIR/downloaded" |
                tee "$MSG_DIR/succeeded"
            env:
              DOWNLOAD_DIR: "$(Pipeline.Workspace)/downloaded"
              SIGNED_DIR: "$(Pipeline.Workspace)/signed"
              MSG_DIR: "$(Pipeline.Workspace)/messages"
          - bash: |
              readarray -t failed < <(jq -r '.[] | .content | fromjson.artifact.name' < "$MSG_DIR/failed_singing_or_publishing")
              for f in "${failed[@]}"; do
                printf '##vso[task.logissue type=error;]failed signing or uploading:  %s\n' "$f"
              done
            env:
              MSG_DIR: "$(Pipeline.Workspace)/messages"
            displayName: Surface failed uploads
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(Pipeline.Workspace)/messages"
              artifactName: messages
  # - stage: FixupQueue
  #   jobs:
  #     - job: SignPackages
  #       pool: $(build.pool)
  #       steps:
  #         - download: current
  #           artifact: messages
  #         - bash: |
  #             cp -r $(Pipeline.Workspace)/downloaded $(Pipeline.Workspace)/signed
  #         - template: templates/sign.steps.windows.yml
  #           parameters:
  #             folderPath: $(Pipeline.Workspace)/signed
  #             pattern: '*.exe'
  #         - template: templates/sign.steps.linux.yml
  #           parameters:
  #             folderPath: $(Pipeline.Workspace)/signed
  #             pattern: '*'
  # - stage: Sign
  #   jobs:
  #     - job: SignPackages
  #       pool: production-pool-amd64-mariner-2
  #       steps:
  #         - download: current
  #           artifact: messages
  #         - bash: |
  #             set -exu
  #             # downloads all packages, puts them in out-dir, logs successful downloads to stdout (put in 'downloaded' file)
  #             mkdir -vp "$MSG_DIR"
  #             go run ./cmd/pop download --out-dir="$OUT_DIR" --messages-file="$MSG_DIR/message" | tee "$MSG_DIR/downloaded"
  #           env:
  #             MSG_DIR: "$(Pipeline.Workspace)/messages"
  #             OUT_DIR: "$(Pipeline.Workspace)/signed"
          # sign script
          # - bash: |
          #     # uploads signed packages, logs successful uploads to stdout (put in 'success' file)
          #     go run ./cmd/pop upload --in-dir="$IN_DIR" --messages-file="$MSG_DIR/downloaded" | tee "$MSG_DIR/success"
          #   env:
          #     IN_DIR: "$(Pipeline.Workspace)/signed"
          # - task: PublishBuildArtifacts@1
          #   inputs:
          #     pathToPublish: "$(Pipeline.Workspace)/messages"
          #     artifactName: messages
  # - stage: Clean Queue
  #   jobs:
  #     - job: Read Queue
  #       pool: $(build.pool)
  #       steps:
  #         - download: current
  #           artifact: messages
  #         - bash: |
  #             go run ./cmd/pop delete --messages-file="$MSG_DIR/success"
  #           env:
  #             MSG_DIR: "$(Pipeline.Workspace)/messages"
